/*@!Encoding:65001*/
includes
{
  
}

variables
{
  msTimer SbWS_timer;
  timer Reset_T;
  byte is_off=0;
  
  // VCU's
  byte ecuisPrimary=0;
  byte SbWS_Machinstate =0;
  word ecuStatusMsgCnt =0;
  byte primaryBus =0;
  byte SbWS_FailCount;
  byte SbWS_FailInfo;
  
  byte modeState; // vehicle mode 0(normal) 1(caution) 2(emergency)
  byte setPrimaryAct; // 0 or 1 to select 
  byte isHealthyBus; // 0(none),1,2,3(both)
  
  int wheelSpeed=0;
  
  // Self Data
  byte isPrimary=0;
  byte MachineState=0;
  
  long SteerDriverAngle;
  long SteerDriverAngle_before=0;
  int SteerDriverTorque=0;
  
  float SteerAngle=0;
  float SteerAngleBefore=0;
  int SteerWheelTorque=0;
  byte SteerConnectionState=0;
  int carspeed=0;
  
  byte isHandleOn=0;
  
  enum MalfunctionState {
  MALFUNCTION_NONFAULT,
  MALFUNCTION_TRANSCEIVER_ERR,
  MALFUNCTION_LOGIC_ERR
  };
  
  
  
  // Actuator info
  byte PrimaryAct; // 0 or 1
  int SteerFeedback;
  
  
 
}

on start
{
  setTimerCyclic(SbWS_timer,10);
}

on timer Reset_T{
  is_off=0;
  ecuisPrimary =0;
  SbWS_Machinstate =0;
  ecuStatusMsgCnt =0;
  primaryBus =1;
  SbWS_FailCount=0;
  SbWS_FailInfo=0;
}

on message CCAN1::DriveModeStatus{
  modeState = this.ModeState;
    if (modeState == 0) {

    } 
    else if (modeState == 1) { 
    
    } 
    else if (modeState == 2) {
    
    } 
    else {
    
    }
}

on message SetSteer{
   if(MachineState == !MALFUNCTION_TRANSCEIVER_ERR){
  if(this.SetPrimarySensorSteer){
    isPrimary=0;
    SteerConnectionState=1;
    //for S1
  }
  else{
    isPrimary=1;
    SteerConnectionState=1;
   //for S0
  }
   }
}

on message PowertrainStatus{
   if(MachineState == !MALFUNCTION_TRANSCEIVER_ERR){
 carspeed=this.VehicleSpeed; 
   }
}

on message SbWA0_Status{
   if(MachineState == !MALFUNCTION_TRANSCEIVER_ERR){
  if(this.EcuIsPrimary == 0){
   PrimaryAct=1; 
  } 
   }
}

on message SbWA1_Status{
   if(MachineState == !MALFUNCTION_TRANSCEIVER_ERR){
  if(this.EcuIsPrimary == 0){
   PrimaryAct=0; 
  } 
}
}



on message CommandResetSteer{
   if(MachineState == !MALFUNCTION_TRANSCEIVER_ERR){
  if(this.HardResetSbWS0){
      is_off = 1;
    setTimer(Reset_T, 3);
 }
   }
}

on message CANHealthyCheck{
   if(MachineState == !MALFUNCTION_TRANSCEIVER_ERR){
 if(!this.CAN1Healthy){
   if(!this.CAN2Healthy){
      primaryBus = 0; 
    }
    else{
      primaryBus =2;   
    }
 }
 else{
     primaryBus = 1;    
   
 }
   }
}


on message SteerFeedback0{
  if(MachineState == !MALFUNCTION_TRANSCEIVER_ERR){
    
    if (PrimaryAct == 0){
        if(SteerAngle != this.SteerFeedbackAngle){
          
    }
    }
  }
  }


on timer SbWS_timer
{
  if(!is_off){
    
    if(isHandleOn){
      //Todo, SteerDriverAngle을 시스템변수로 최신화  
      SteerAngle = CalcAngle(SteerAngleBefore, SteerDriverAngle, carspeed);
      SteerDriverAngle=SteerAngle*16;
      SteerAngleBefore=SteerAngle;

    }
    else{
      //isHandle Off
      SteerAngle-=CalcRestoreAngle(SteerAngle,carspeed);
      SteerDriverAngle=SteerAngle*16;
      
    }
  TransmitSteerCommand0();
  TransmitDriverStatus0();
  TransmitSensor0FailStatus();
  TransmitStatus();
  }
}


float pow(float base, float exponent) {
    // 음수 기반에 대한 제한 처리
    int i;
    if (base < 0 && (exponent - (int)exponent) != 0) {
        return 0.0;
    }

    // 0^0은 정의되지 않음
    if (base == 0 && exponent <= 0) {
        return 0.0;
    }

    // 지수가 0인 경우 결과는 항상 1
    if (exponent == 0) {
        return 1.0;
    }

    // 음수 지수 처리: base^(-exponent) = 1 / (base^exponent)
    if (exponent < 0) {
        return 1.0 / pow(base, -exponent);
    }

    // 반복문을 통한 계산 (지수가 정수일 경우 최적화)
    if ((exponent - (int)exponent) == 0) { // 정수 지수 확인
        float result = 1.0;
        for (i = 0; i < (int)exponent; i++) {
            result *= base;
        }
        return result;
    }

    // 비정수 지수 처리: base^exponent = exp(exponent * ln(base))
    return exp(exponent * logApprox(base)); // CAPL 기본 수학 함수 활용
}

// 근사된 로그 함수 구현
float logApprox(float x) {
  float estimate;
  float diff;
  float tolerance;
    if (x <= 0) {
        return 0.0;
    }

    // 로그 근사값 계산을 위한 초기 값
    estimate = x - 1;  // 초기 추정 값
    tolerance = 0.0001;  // 허용 오차
    diff = 1.0;

    // 뉴턴-랩슨 방법으로 근사 계산
    while (abs(diff) > tolerance) {
        diff = (x - exp(estimate)) / x;  // 로그 근사를 위한 차이 계산
        estimate = estimate + diff;
    }

    return estimate;
}



float CalcRestoreAngle(float theta, float speed) {
    float k = 0.05; // 복원 강도 계수 (조정 가능)
    float max_restore = 0.2; // 20ms당 최대 변화량 (1초당 10도)
    float alpha = 0.5; // 비선형 복원 지수 (0 < alpha < 1)
    float delta_theta;
    // 정지 상태에서는 복원 없음
    if (speed <= 0) return 0.0;

    // 복원 각도 변화량 계산
    delta_theta = k * pow(abs(theta), alpha);

    // 최대 변화량 제한
    if (delta_theta > max_restore) {
        delta_theta = max_restore;
    }

    // 부호에 따라 복원 각도 조정
    delta_theta *= (theta > 0) ? -1 : 1;

    // 0에 가까워질 경우 0으로 고정
    if (abs(theta) < delta_theta) {
        delta_theta = -theta; // 남은 각도만큼만 복원
    }

    return delta_theta;
}

float CalcAngle(float theta_bf,int driver_angle,int speed) {
  float theta;
  theta=driver_angle/16;
    if (speed >= 40 && speed < 80) {
        // 20ms당 변화량이 0.2도를 넘지 않도록 제한
        if (abs(theta - theta_bf) > 0.1) {
            theta = (theta > theta_bf) ? theta_bf + 0.2 : theta_bf - 0.2;
        }
        //최대 조향 각도가 20을 넘지 않도록 함.
        if (abs(theta) > 20) {
            theta = (theta < 0) ? -20 : 20; 
        }
    } else if (speed >= 80) {
        // 20ms당 변화량이 0.1도를 넘지 않도록 제한
        if (abs(theta - theta_bf) > 0.1) {
            theta = (theta > theta_bf) ? theta_bf + 0.1 : theta_bf - 0.1;
        }
        // 최대 조향 각도가 10도를 넘지 않도록 제한
        if (abs(theta) > 10) {
            theta = (theta < 0) ? -10 : 10;
        }
    }
    return theta;
}



void Transmit(message * msg) {
  if(MachineState == MALFUNCTION_TRANSCEIVER_ERR)
    return;
  if(primaryBus==3) {
      msg.can=1;
      output(msg);
      msg.can=2;
      output(msg);
      }
  else
  {
    msg.can=primaryBus;
    output(msg);
  }
}

void TransmitStatus(){
  message SbWS0_Status status;
  status.EcuIsPrimary.phys=isPrimary;
  status.SbWS_MachineState.phys=MachineState;
  status.EcuStatusMsgCount.phys=ecuStatusMsgCnt;
  status.PrimaryBus.phys=primaryBus;
  Transmit(status);
  if(!MALFUNCTION_TRANSCEIVER_ERR)
  ecuStatusMsgCnt++;
}

  
 void TransmitDriverStatus0(){
   message SteerDriverState0 DriverState;
   DriverState.SteerDriverAngle.phys = SteerDriverAngle;
   DriverState.SteerDriverTorque.phys =SteerDriverTorque;
   
   Transmit(DriverState);
 }
 
 void TransmitSensor0FailStatus(){
   message SteerSensor0FailStatus FailStatus;
   FailStatus.SbWS_FailCount.phys=SbWS_FailCount;
  FailStatus.SbWS_FailInfo.phys = SbWS_FailInfo;   
   Transmit(FailStatus);
 } 

void TransmitSteerCommand0(){
  if(ecuisPrimary){
  message SteerCommand0 cmd;
  cmd.SteerAngle.phys = SteerAngle;
  cmd.SteerWheelTorque.phys=SteerWheelTorque;
  cmd.SteerConnectionState.phys = SteerConnectionState;
  Transmit(cmd);
  }
}

on message 0x500{
  MachineState = MALFUNCTION_NONFAULT;
}

on message 0x501{
  MachineState = MALFUNCTION_TRANSCEIVER_ERR;
}

on message 0x502{
  MachineState = MALFUNCTION_LOGIC_ERR;
}

